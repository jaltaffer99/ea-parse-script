import argparse
import pandas as pd
import numpy as np
from datetime import timedelta
import re
import matplotlib.pyplot as plt


def parse(input_file, circuit):
    """Parse a file generated by the Metasys application

    Args:
        input_file: string, indicating path of Metasys file

    Returns:
        pandas DataFrame, with timestamps as index and measurement variables as columns
    """
    # Read the file into a pandas Series with MultiIndex
    df = pd.read_csv(input_file, index_col=[0, 1])['Object Value']
        
    # Drop duplicate measurements
    df = df.groupby(df.index).last()
    
    df.index = pd.MultiIndex.from_tuples(df.index)
    
    # Remove units from values, so that they are numeric
    df = df.apply(drop_units)
    

    # Transform df from 1-dimensional Series with MultiIndex to 2-dimensional DataFrame
    df = df.unstack(level=-1)
    
    # Remove prefixes from column names
    df.columns = [drop_prefix(column_name) for column_name in df.columns]
    
    # Convert index to DatetimeIndex
    if circuit == 'Gas':
        df.index = pd.to_datetime(df.index, dayfirst=False)
    else:
        df.index = pd.to_datetime(df.index, dayfirst=True)
    a = df.axes
    b = a[0]
    
    return df


def drop_prefix(variable_name):
    """Remove the 'Town Of Andover:AHS-NAE1/FEC Bus2.' prefix from variable names"""
    pattern = re.compile(r"\ATown Of Andover:AHS-NAE1/FEC Bus2\.(.*)\Z")
    match = pattern.match(variable_name)
    if match is None:
        # variable_name was not of the expected format
        return np.nan
    else:
        return match.group(1)


def drop_units(value):
    """Remove the units from a string, e.g. '309.2 kWh' -> 309.2"""
    
    try:
        float(value)
        return value
    except ValueError:
        pattern = re.compile(r"\A(\d*\.?\d+) [a-zA-Z]+\Z")
        match = pattern.match(value)
        
        if match is None:
            # value was not of the expected format
            return np.nan
        else:
            return float(match.group(1))


def summarize(df, cost, circuit, start_time=None, end_time=None):
    """Return a table describing daily energy usage"""
    #df.to_csv('dataframe.csv')
    if circuit == 'Gas':
       start_time = '0:00'
       end_time = '22:00'
    #df.to_csv('dataframe.csv')
    if end_time is not None and start_time is None:
        raise ValueError('end_time should not be specified unless start_time is specified')
    elif start_time is not None and end_time is not None and circuit != 'Gas':
        df = df.iloc[df.index.indexer_between_time(start_time, end_time),:]
        #df.to_csv('dataframe2.csv')
    summary_columns = []
    summary_labels = []
    if circuit == '?':
        print ('\n\nCommands:\n-c \'\' -- Returns all data types\n' +
            '-c \'Gas\' --return Gas data. Regardless of time input, always exports data between 0:00 and 22:00\n\n'
            'The following commands can also be used together to create a combination of data types:\n' +
            '-c \'Main\' --returns Main data\n' +
            '-c \'CC\' --returns Collins Center data\n' +
            '-c \'DHB\' --returns DHB data\n' +
            '-c \'DG\' --returns DG data\n' +
            '-c \'DL\' --returns DL data\n' +
            '-c \'DE-ATS\' --returns DE-ATS data\n' +
            '-c \'M1\' --returns M1 data\n')
        raise SystemExit(0)
    if circuit.find('Gas') != -1:
        summary_columns.append('MAIN ELECTRIC METER.Analog Inputs.Gas Meter.Cubic Feet of Gas (Trend1)')
        summary_labels.append('Gas')
    if circuit.find('CC') != -1:
        summary_columns.append('PANEL COLLINS ELECTRIC METER.Analog Inputs.Energy.CollinCtr-Energy-kWh (Trend1)')
        summary_labels.append('Collins')
    if circuit.find('Main') != -1 :
        summary_columns.append('MAIN ELECTRIC METER.Analog Inputs.Energy.Main-kWh-Energy (Trend1)')
        summary_labels.append('Main')
    if circuit.find('DHB') != -1:
        summary_columns.append('PANEL DHB ELECTRIC METER.Analog Inputs.Energy.DHB - kWh Total (Trend1)')
        summary_labels.append('DHB')
    if circuit.find('M1') != -1:
        summary_columns.append('PANEL M1 ELECTRIC METER.Analog Inputs.Energy.M1-kWh-Energy (Trend1)')
        summary_labels.append('M1')
    if circuit.find('DG') != -1:
        summary_columns.append('PANEL DG ELECTRIC METER.Analog Inputs.Energy.DG-kWh-Energy (Trend1)')
        summary_labels.append('DG')
    if circuit.find('DE-ATS') != -1:
        summary_columns.append('PANEL DE-ATS ELECTRIC METER.Analog Inputs.Energy.DE-ATS-Energy-kWh (Trend1)')
        summary_labels.append('DE-ATS')
    if circuit.find('DL') != -1:
        summary_columns.append('PANEL DL ELECTRIC METER.Analog Inputs.Energy.DL-Energy-kWh (Trend1)')
        summary_labels.append('DL')
    if circuit == ' ':
        summary_columns = [
           'MAIN ELECTRIC METER.Analog Inputs.Energy.Main-kWh-Energy (Trend1)',
            'PANEL DHB ELECTRIC METER.Analog Inputs.Energy.DHB - kWh Total (Trend1)',
            'PANEL M1 ELECTRIC METER.Analog Inputs.Energy.M1-kWh-Energy (Trend1)',
            'PANEL DG ELECTRIC METER.Analog Inputs.Energy.DG-kWh-Energy (Trend1)',
            'PANEL DE-ATS ELECTRIC METER.Analog Inputs.Energy.DE-ATS-Energy-kWh (Trend1)',
            'PANEL COLLINS ELECTRIC METER.Analog Inputs.Energy.CollinCtr-Energy-kWh (Trend1)',
            'PANEL DL ELECTRIC METER.Analog Inputs.Energy.DL-Energy-kWh (Trend1)'
        ]
        summary_labels = ['Main', 'DHB', 'M1', 'DG', 'DE-ATS', 'Collins', 'DL']
        
    if summary_labels[0] == 'Gas':
       cost = 1
    
    subset = df[summary_columns]
    # Sometimes measurements are incorrectly reported as 0
    subset = subset.replace(to_replace=0, value=np.nan)
    
    grouped = subset.groupby(group_key(subset, start_time, end_time))

    grouped_cumulative_energy = grouped[summary_columns]

    daily_energy = grouped_cumulative_energy.max() - grouped_cumulative_energy.min()
    daily_energy.columns = [label + ' (kWh)' for label in summary_labels]
    daily_dollars = daily_energy * cost
    daily_dollars.columns = [label + ' ($)' for label in summary_labels]

    #print (grouped_cumulative_energy.max())
    #print (grouped_cumulative_energy.min())
    return pd.concat((daily_energy, daily_dollars), axis=1)


def group_key(df, start_time, end_time):
    """Return a key by which to group measurements"""
    if start_time is None and end_time is None:
        return df.index.date
    elif start_time is not None and end_time is None:
        # associate times before start_time with the previous day
        return df.index.shift(-1, to_timedelta(start_time)).date
    elif end_time is not None:
        start_timedelta = to_timedelta(start_time)
        end_timedelta = to_timedelta(end_time)
        if start_timedelta < end_timedelta:
            # measurement is of daytime usage, so no need to shift
            return df.index.date
        else:
            # measurement is of nighttime usage, so need to associate times with dates wisely
            return df.index.shift(-1, 0.5 * (start_timedelta + end_timedelta)).date


def to_timedelta(time_string):
    hours, minutes = map(int, time_string.split(':'))
    return timedelta(hours=hours, minutes=minutes)


def header(start_time, end_time):
    """Return a header to print at the top of output files"""
    if end_time is None:
        if start_time is None:
            return 'Usage statistics from all hours of each day'
        else:
            return 'Usage statistics start at %s each day' % start_time
    else:
        return 'Usage statistics from between %s and %s each day' % (start_time, end_time)


def save_df(df, summarize, start_time, end_time, output_file):
    """Save input DataFrame to a csv file"""
    if summarize:
        with open(output_file, 'w') as output_file:
            output_file.write(header(start_time, end_time))
            output_file.write('\n')
            transformed.to_csv(output_file, mode='a')
    else:
        transformed.to_csv(output_file)

def graph(circuit, transformed):
    margin = 0
    if circuit.find('Gas') != -1:
        margin += 1
    if circuit.find('CC') != -1:
        margin += 1
    if circuit.find('Main') != -1:
        margin += 1
    if circuit.find('DHB') != -1:
        margin += 1
    if circuit.find('M1') != -1:
        margin += 1
    if circuit.find('DG') != -1:
        margin += 1
    if circuit.find('DE-ATS') != -1:
        margin += 1
    if circuit.find('DL') != -1:
        margin += 1
    if circuit == ' ':
        margin = 7
    xValues = []
    count = 0
    circuit += " "
    end = circuit.index(" ")
    guideCircuit = circuit[0:end]
    for i in transformed[guideCircuit + " (kWh)"].tolist():
        xValues.append((count * margin))
        count += 1

    xSize = len(xValues)
    if circuit.find('Gas') != -1:
        gasValues = transformed["Gas (kWh)"].tolist()
        plt.bar(xValues, gasValues, label = "Gas", color = "brown")
        for i in range(0, len(xValues)):
            xValues[i] += 1
    if circuit.find('CC') != -1:
        cCValues = transformed["Collins (kWh)"].tolist()
        plt.bar(xValues, cCValues, label = "Collins Center", color = "blue")
        for i in range(0, len(xValues)):
            xValues[i] += 1
    if circuit.find('Main') != -1 :
        mainValues = transformed["Main (kWh)"].tolist()
        plt.bar(xValues, mainValues, label = "Main", color = "red")
        for i in range(0, len(xValues)):
            xValues[i] += 1
    if circuit.find('DHB') != -1:
        dHBValues = transformed["DHB (kWh)"].tolist()
        plt.bar(xValues, dHBValues, label = "DHB", color = "green")
        for i in range(0, len(xValues)):
            xValues[i] += 1
    if circuit.find('M1') != -1:
        m1Values = transformed["M1 (kWh)"].tolist()
        plt.bar(xValues, m1Values, label = "M1", color = "yellow")
        for i in range(0, len(xValues)):
            xValues[i] += 1
    if circuit.find('DG') != -1:
        dGValues = transformed["DG (kWh)"].tolist()
        plt.bar(xValues, dGValues, label = "DG", color = "purple")
        for i in range(0, len(xValues)):
            xValues[i] += 1
    if circuit.find('DE-ATS') != -1:
        dEATSValues = transformed["DE-ATS (kWh)"].tolist()
        plt.bar(xValues, dEATSValues, label = "DE-ATS", color = "orange")
        for i in range(0, len(xValues)):
            xValues[i] += 1
    if circuit.find('DL') != -1:
        dLValues = transformed["DL (kWh)"].tolist()
        plt.bar(xValues, dLValues, label = "DL", color = "black")
    if circuit == ' ':
        cCValues = transformed["Collins (kWh)"].tolist()
        mainValues = transformed["Main (kWh)"].tolist()
        dHBValues = transformed["DHB (kWh)"].tolist()
        m1Values = transformed["M1 (kWh)"].tolist()
        dGValues = transformed["DG (kWh)"].tolist()
        dEATSValues = transformed["DE-ATS (kWh)"].tolist()
        dLValues = transformed["DL (kWh)"].tolist()
        plt.bar(xValues, cCValues, label = "Collins Center", color = "blue")
        for i in range(0, len(xValues)):
            xValues[i] += 1
        plt.bar(xValues, mainValues, label = "Main", color = "red")
        for i in range(0, len(xValues)):
            xValues[i] += 1
        plt.bar(xValues, dHBValues, label = "DHB", color = "green")
        for i in range(0, len(xValues)):
            xValues[i] += 1
        plt.bar(xValues, m1Values, label = "M1", color = "yellow")
        for i in range(0, len(xValues)):
            xValues[i] += 1
        plt.bar(xValues, dGValues, label = "DG", color = "purple")
        for i in range(0, len(xValues)):
            xValues[i] += 1
        plt.bar(xValues, dEATSValues, label = "DE-ATS", color = "orange")
        for i in range(0, len(xValues)):
            xValues[i] += 1
        plt.bar(xValues, dLValues, label = "DL", color = "black")
    
    #dates = transformed[transformed.columns[0]]
    plt.xlabel('Day')
    plt.ylabel('kWh')
    plt.title("Electrical Data")
    plt.legend()
    x = []
    xTicks = []
    numDaysInterval = 4
    for i in range (0, len(xValues), numDaysInterval * margin):
        x.append(xValues[i])

    axes = transformed.axes
    xAxis = axes[0]
    summarizedXAxis = []
    for i in range (0, len(xAxis),numDaysInterval):
        summarizedXAxis.append(xAxis[i])
    plt.xticks(x,summarizedXAxis, rotation = "vertical")
    plt.show()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='script for parsing Metasys data files')
    parser.add_argument('-s', '--summarize', dest='summarize', action='store_true',
                        help='option indicating whether output file should be a summary')
    parser.add_argument('--start', dest='start_time', nargs='?',
                        help='start time for summary table')
    parser.add_argument('--end', dest='end_time', nargs='?', help='end time for summary table')
    parser.add_argument('-i', dest='input_file',  help='name of input file')
    parser.add_argument('-o', dest='output_file', help='name of output file')
    parser.add_argument('-c', dest='circuit', help='data from circuit')
    parser.add_argument('--cost', dest='cost', nargs='?', default=.16,
                        help='cost of electricity, in $/kWh', type=float)
    args = parser.parse_args()
    transformed = parse(args.input_file, args.circuit)
    if args.summarize:
        transformed = summarize(transformed, args.cost, args.circuit, args.start_time, args.end_time)

    output = "Desktop/MetasysParsing/" + args.output_file
    save_df(transformed, args.summarize, args.start_time, args.end_time, output)
    print("Finished parsing file, output is saved as: " + args.output_file + " and is saved in Desktop/MetasysParsing")
    graph(args.circuit, transformed)